/*
 * The Plaid API
 * The Plaid REST API. Please see https://plaid.com/docs/api for more details.
 *
 * The version of the OpenAPI document: 2020-09-14_1.64.13
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SignalDecisionReportRequest defines the request schema for &#x60;/signal/decision/report&#x60;
 */
@ApiModel(description = "SignalDecisionReportRequest defines the request schema for `/signal/decision/report`")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-06-13T10:01:14.758140-04:00[America/New_York]")
public class SignalDecisionReportRequest {
  public static final String SERIALIZED_NAME_CLIENT_ID = "client_id";
  @SerializedName(SERIALIZED_NAME_CLIENT_ID)
  private String clientId;

  public static final String SERIALIZED_NAME_SECRET = "secret";
  @SerializedName(SERIALIZED_NAME_SECRET)
  private String secret;

  public static final String SERIALIZED_NAME_CLIENT_TRANSACTION_ID = "client_transaction_id";
  @SerializedName(SERIALIZED_NAME_CLIENT_TRANSACTION_ID)
  private String clientTransactionId;

  public static final String SERIALIZED_NAME_INITIATED = "initiated";
  @SerializedName(SERIALIZED_NAME_INITIATED)
  private Boolean initiated;

  public static final String SERIALIZED_NAME_DAYS_FUNDS_ON_HOLD = "days_funds_on_hold";
  @SerializedName(SERIALIZED_NAME_DAYS_FUNDS_ON_HOLD)
  private Integer daysFundsOnHold;

  public SignalDecisionReportRequest() { 
  }

  public SignalDecisionReportRequest clientId(String clientId) {
    
    this.clientId = clientId;
    return this;
  }

   /**
   * Your Plaid API &#x60;client_id&#x60;. The &#x60;client_id&#x60; is required and may be provided either in the &#x60;PLAID-CLIENT-ID&#x60; header or as part of a request body.
   * @return clientId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Your Plaid API `client_id`. The `client_id` is required and may be provided either in the `PLAID-CLIENT-ID` header or as part of a request body.")

  public String getClientId() {
    return clientId;
  }


  public void setClientId(String clientId) {
    this.clientId = clientId;
  }


  public SignalDecisionReportRequest secret(String secret) {
    
    this.secret = secret;
    return this;
  }

   /**
   * Your Plaid API &#x60;secret&#x60;. The &#x60;secret&#x60; is required and may be provided either in the &#x60;PLAID-SECRET&#x60; header or as part of a request body.
   * @return secret
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Your Plaid API `secret`. The `secret` is required and may be provided either in the `PLAID-SECRET` header or as part of a request body.")

  public String getSecret() {
    return secret;
  }


  public void setSecret(String secret) {
    this.secret = secret;
  }


  public SignalDecisionReportRequest clientTransactionId(String clientTransactionId) {
    
    this.clientTransactionId = clientTransactionId;
    return this;
  }

   /**
   * Must be the same as the &#x60;client_transaction_id&#x60; supplied when calling &#x60;/signal/evaluate&#x60;
   * @return clientTransactionId
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Must be the same as the `client_transaction_id` supplied when calling `/signal/evaluate`")

  public String getClientTransactionId() {
    return clientTransactionId;
  }


  public void setClientTransactionId(String clientTransactionId) {
    this.clientTransactionId = clientTransactionId;
  }


  public SignalDecisionReportRequest initiated(Boolean initiated) {
    
    this.initiated = initiated;
    return this;
  }

   /**
   * &#x60;true&#x60; if the ACH transaction was initiated, &#x60;false&#x60; otherwise.
   * @return initiated
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "`true` if the ACH transaction was initiated, `false` otherwise.")

  public Boolean getInitiated() {
    return initiated;
  }


  public void setInitiated(Boolean initiated) {
    this.initiated = initiated;
  }


  public SignalDecisionReportRequest daysFundsOnHold(Integer daysFundsOnHold) {
    
    this.daysFundsOnHold = daysFundsOnHold;
    return this;
  }

   /**
   * The actual number of days (hold time) since the ACH debit transaction that you wait before making funds available to your customers. The holding time could affect the ACH return rate. For example, use 0 if you make funds available to your customers instantly or the same day following the debit transaction, or 1 if you make funds available the next day following the debit initialization.
   * minimum: 0
   * @return daysFundsOnHold
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The actual number of days (hold time) since the ACH debit transaction that you wait before making funds available to your customers. The holding time could affect the ACH return rate. For example, use 0 if you make funds available to your customers instantly or the same day following the debit transaction, or 1 if you make funds available the next day following the debit initialization.")

  public Integer getDaysFundsOnHold() {
    return daysFundsOnHold;
  }


  public void setDaysFundsOnHold(Integer daysFundsOnHold) {
    this.daysFundsOnHold = daysFundsOnHold;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SignalDecisionReportRequest signalDecisionReportRequest = (SignalDecisionReportRequest) o;
    return Objects.equals(this.clientId, signalDecisionReportRequest.clientId) &&
        Objects.equals(this.secret, signalDecisionReportRequest.secret) &&
        Objects.equals(this.clientTransactionId, signalDecisionReportRequest.clientTransactionId) &&
        Objects.equals(this.initiated, signalDecisionReportRequest.initiated) &&
        Objects.equals(this.daysFundsOnHold, signalDecisionReportRequest.daysFundsOnHold);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientId, secret, clientTransactionId, initiated, daysFundsOnHold);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SignalDecisionReportRequest {\n");
    sb.append("    clientId: ").append(toIndentedString(clientId)).append("\n");
    sb.append("    secret: ").append(toIndentedString(secret)).append("\n");
    sb.append("    clientTransactionId: ").append(toIndentedString(clientTransactionId)).append("\n");
    sb.append("    initiated: ").append(toIndentedString(initiated)).append("\n");
    sb.append("    daysFundsOnHold: ").append(toIndentedString(daysFundsOnHold)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("client_id");
    openapiFields.add("secret");
    openapiFields.add("client_transaction_id");
    openapiFields.add("initiated");
    openapiFields.add("days_funds_on_hold");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("client_transaction_id");
    openapiRequiredFields.add("initiated");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to SignalDecisionReportRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (SignalDecisionReportRequest.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in SignalDecisionReportRequest is not found in the empty JSON string", SignalDecisionReportRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!SignalDecisionReportRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SignalDecisionReportRequest` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : SignalDecisionReportRequest.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (jsonObj.get("client_id") != null && !jsonObj.get("client_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client_id").toString()));
      }
      if (jsonObj.get("secret") != null && !jsonObj.get("secret").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secret` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secret").toString()));
      }
      if (jsonObj.get("client_transaction_id") != null && !jsonObj.get("client_transaction_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client_transaction_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client_transaction_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SignalDecisionReportRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SignalDecisionReportRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SignalDecisionReportRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SignalDecisionReportRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<SignalDecisionReportRequest>() {
           @Override
           public void write(JsonWriter out, SignalDecisionReportRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SignalDecisionReportRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of SignalDecisionReportRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of SignalDecisionReportRequest
  * @throws IOException if the JSON string is invalid with respect to SignalDecisionReportRequest
  */
  public static SignalDecisionReportRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SignalDecisionReportRequest.class);
  }

 /**
  * Convert an instance of SignalDecisionReportRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

